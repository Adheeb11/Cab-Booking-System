# üéì OOP Concepts Demonstration

This document explains how each Object-Oriented Programming concept is implemented in the Cab Booking System.

## 1. üîí Encapsulation

**Definition**: Bundling data (attributes) and methods that operate on that data within a single unit (class), and restricting direct access to some components.

### Implementation

#### User Entity
```java
@Entity
@Data  // Lombok generates getters/setters
public class User {
    @Id
    private Long userId;      // Private field
    private String name;       // Private field
    private String email;      // Private field
    private String phone;      // Private field
    
    // Getters and setters are auto-generated by Lombok
    // External classes cannot directly access these fields
}
```

**Key Points:**
- All fields are `private`
- Access is controlled through getters/setters
- Data validation can be added in setters
- Protects object state from unwanted modifications

#### Cab Entity
```java
@Entity
@Data
public class Cab {
    private Long cabId;
    private String cabNumber;
    private Double ratePerKm;
    private Boolean isElectric;
    
    // Business logic encapsulated within the class
    public Double calculateFare(Double distance) {
        return this.ratePerKm * distance;
    }
}
```

**Benefits:**
- ‚úÖ Data hiding
- ‚úÖ Controlled access
- ‚úÖ Flexibility to change implementation
- ‚úÖ Enhanced security

---

## 2. üß¨ Inheritance

**Definition**: Mechanism where a new class derives properties and behaviors from an existing class.

### Implementation: Payment Hierarchy

#### Base Class (Parent)
```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public abstract class Payment {
    @Id
    private Long paymentId;
    private Double amount;
    private String paymentStatus;
    private LocalDateTime transactionTime;
    
    // Abstract method - must be implemented by children
    public abstract String processPayment();
    
    // Concrete method - inherited by all children
    public String getPaymentDetails() {
        return "Payment ID: " + paymentId + ", Amount: " + amount;
    }
}
```

#### Child Classes

**UPI Payment**
```java
@Entity
@DiscriminatorValue("UPI")
public class UPIPayment extends Payment {
    private String upiId;
    private String transactionId;
    
    @Override
    public String processPayment() {
        this.setPaymentStatus("SUCCESS");
        return "UPI Payment Processed: " + upiId;
    }
}
```

**Card Payment**
```java
@Entity
@DiscriminatorValue("CARD")
public class CardPayment extends Payment {
    private String cardNumber;
    private String cardType;
    private String bankName;
    
    @Override
    public String processPayment() {
        this.setPaymentStatus("SUCCESS");
        return "Card Payment Processed: ****" + cardNumber;
    }
}
```

**Cash Payment**
```java
@Entity
@DiscriminatorValue("CASH")
public class CashPayment extends Payment {
    private Double receivedAmount;
    private Double changeReturned;
    
    @Override
    public String processPayment() {
        this.setPaymentStatus("SUCCESS");
        return "Cash Payment: " + receivedAmount;
    }
}
```

**Inheritance Hierarchy:**
```
        Payment (Abstract)
           /    |    \
          /     |     \
    UPIPayment  |  CashPayment
                |
           CardPayment
```

**Benefits:**
- ‚úÖ Code reusability
- ‚úÖ Method overriding
- ‚úÖ Hierarchical classification
- ‚úÖ Single Table Inheritance in database

---

## 3. üé≠ Polymorphism

**Definition**: Ability of objects to take multiple forms. Same method behaves differently based on the object type.

### Implementation: Payment Processing

```java
// In BookingService.java
private Payment createPayment(BookingRequest request, Double fare) {
    // Runtime polymorphism - method returns different types
    return switch (request.getPaymentMethod()) {
        case "UPI" -> new UPIPayment(...);
        case "CARD" -> new CardPayment(...);
        case "CASH" -> new CashPayment(...);
    };
}

// Using polymorphism
Payment payment = createPayment(request, fare);
String result = payment.processPayment(); // Different behavior!
```

**How it works:**

1. **Compile Time**: Variable type is `Payment`
2. **Runtime**: Actual object can be `UPIPayment`, `CardPayment`, or `CashPayment`
3. **Method Call**: `processPayment()` executes the specific implementation

**Example Flow:**
```java
// Case 1: UPI
Payment payment = new UPIPayment(...);
payment.processPayment(); 
// Output: "‚úÖ UPI Payment Processed Successfully!"

// Case 2: Card
Payment payment = new CardPayment(...);
payment.processPayment(); 
// Output: "‚úÖ Card Payment Processed Successfully!"

// Case 3: Cash
Payment payment = new CashPayment(...);
payment.processPayment(); 
// Output: "‚úÖ Cash Payment Processed Successfully!"
```

**Benefits:**
- ‚úÖ Flexible code
- ‚úÖ Easy to extend (add new payment methods)
- ‚úÖ Loose coupling
- ‚úÖ Cleaner code

**Real-world analogy:**
Think of a "Vehicle" class. A car, bike, and truck are all vehicles, but they move differently. `vehicle.move()` works for all, but implementation differs.

---

## 4. üé® Abstraction

**Definition**: Hiding complex implementation details and showing only essential features.

### Implementation 1: Abstract Class

```java
@Entity
public abstract class Payment {
    // Concrete fields
    private Long paymentId;
    private Double amount;
    
    // Abstract method - no implementation
    public abstract String processPayment();
    
    // Concrete method - has implementation
    public String getPaymentDetails() {
        return "Payment: " + paymentId;
    }
    
    // Another concrete method
    public boolean validatePayment() {
        return amount != null && amount > 0;
    }
}
```

**Rules for Abstract Classes:**
- Cannot be instantiated: ‚ùå `new Payment()` 
- Can have abstract AND concrete methods
- Child classes MUST implement abstract methods
- Can have constructors

### Implementation 2: Interface

```java
public interface Payable {
    // Abstract method (implicitly public abstract)
    String processPayment();
    
    String getPaymentDetails();
    
    // Default method (Java 8+)
    default boolean validatePayment() {
        return true;
    }
}
```

**Abstract Class vs Interface:**

| Feature | Abstract Class | Interface |
|---------|---------------|-----------|
| Multiple Inheritance | ‚ùå No | ‚úÖ Yes |
| Implementation | Can have | All abstract (except default) |
| Fields | Can have | Only constants |
| Constructors | ‚úÖ Yes | ‚ùå No |
| When to use | "is-a" relationship | "can-do" relationship |

**Benefits:**
- ‚úÖ Hides complexity
- ‚úÖ Focuses on "what" not "how"
- ‚úÖ Provides contract/template
- ‚úÖ Reduces coupling

---

## 5. üß© Composition

**Definition**: "Has-a" relationship where one class contains objects of other classes.

### Implementation: Booking Composition

```java
@Entity
public class Booking {
    @Id
    private Long bookingId;
    
    // Composition: Booking HAS-A User
    @ManyToOne
    private User user;
    
    // Composition: Booking HAS-A Cab
    @ManyToOne
    private Cab cab;
    
    // Composition: Booking HAS-A Driver
    @ManyToOne
    private Driver driver;
    
    private String pickupLocation;
    private String dropLocation;
    private Double fare;
}
```

**Relationship Diagram:**
```
    Booking
      |
      |-- HAS-A --> User
      |-- HAS-A --> Cab
      |-- HAS-A --> Driver
```

**Composition vs Inheritance:**

| Aspect | Composition | Inheritance |
|--------|-------------|-------------|
| Relationship | Has-a | Is-a |
| Coupling | Loose | Tight |
| Flexibility | High | Low |
| Example | Car has Engine | Car is Vehicle |

**Why Composition is Preferred:**
```java
// ‚ùå Poor design (inheritance)
class Booking extends User { } // Booking IS-A User? No!

// ‚úÖ Good design (composition)
class Booking {
    private User user; // Booking HAS-A User? Yes!
}
```

**Benefits:**
- ‚úÖ More flexible than inheritance
- ‚úÖ Better code reusability
- ‚úÖ Easier to test
- ‚úÖ Follows "favor composition over inheritance" principle

---

## 6. üìö Collections Framework

**Definition**: Java's framework for storing and manipulating groups of objects.

### Implementation in BookingService

```java
@Service
public class BookingService {
    // HashMap for caching available cabs
    private final Map<Long, Cab> availableCabsCache = new HashMap<>();
    
    // ArrayList for recent bookings
    private final List<Booking> recentBookings = new ArrayList<>();
    
    public void cacheAvailableCabs(List<Cab> cabs) {
        // Using Collections - HashMap
        cabs.forEach(cab -> availableCabsCache.put(cab.getCabId(), cab));
    }
    
    public void addToRecentBookings(Booking booking) {
        // Using Collections - ArrayList
        recentBookings.add(booking);
        
        // Keep only last 100 bookings
        if (recentBookings.size() > 100) {
            recentBookings.remove(0);
        }
    }
}
```

**Collections Used:**
- `HashMap<K,V>` - Fast lookup by key
- `ArrayList<E>` - Dynamic array

---

## 7. üßµ Multithreading

**Definition**: Executing multiple threads concurrently for better performance.

### Implementation: Async Payment Processing

```java
@Service
public class BookingService {
    
    public BookingResponse createBooking(BookingRequest request) {
        // ... create booking ...
        
        // Process payment asynchronously (new thread)
        Long bookingId = booking.getBookingId();
        CompletableFuture.runAsync(() -> 
            processPaymentAsync(bookingId, request, fare)
        );
        
        return response; // Return immediately, don't wait for payment
    }
    
    private void processPaymentAsync(Long bookingId, 
                                     BookingRequest request, 
                                     Double fare) {
        // Runs in separate thread
        Thread.sleep(1000); // Simulate processing
        Payment payment = createPayment(booking, request, fare);
        payment.processPayment();
        paymentRepository.save(payment);
    }
}
```

**Benefits:**
- ‚úÖ Non-blocking operations
- ‚úÖ Better performance
- ‚úÖ Improved user experience
- ‚úÖ Scalability

---

## 8. üìÅ File I/O

**Definition**: Reading from and writing to files.

### Implementation: Booking Logs

```java
private void logBookingToFile(Booking booking, String type) {
    try (FileWriter writer = new FileWriter("logs/booking-logs.txt", true)) {
        String log = String.format(
            "%s - %s BOOKING - ID: %d, User: %s, Fare: %.2f%n",
            LocalDateTime.now(), type, booking.getBookingId(),
            booking.getUser().getName(), booking.getFare()
        );
        writer.write(log);
    } catch (IOException e) {
        log.error("Error writing to log file: {}", e.getMessage());
    }
}
```

**Log File Example:**
```
2025-10-04 10:15:23 - NORMAL BOOKING - ID: 1, User: John Doe, Fare: 120.00
2025-10-04 10:17:45 - ECO BOOKING - ID: 2, User: Jane Smith, Fare: 150.00
```

---

## Summary: OOP Concepts in Cab Booking System

| Concept | Location | Example |
|---------|----------|---------|
| **Encapsulation** | All Entities | Private fields with getters/setters |
| **Inheritance** | Payment Classes | UPIPayment extends Payment |
| **Polymorphism** | Payment Processing | `payment.processPayment()` |
| **Abstraction** | Payment Class | Abstract methods |
| **Composition** | Booking Entity | Has-a User, Cab, Driver |
| **Collections** | BookingService | HashMap, ArrayList |
| **Multithreading** | Payment Processing | CompletableFuture |
| **File I/O** | Logging | FileWriter for logs |

---

## üéØ Key Takeaways

1. **Encapsulation** protects data
2. **Inheritance** promotes code reuse
3. **Polymorphism** enables flexible code
4. **Abstraction** hides complexity
5. **Composition** is better than inheritance for "has-a" relationships
6. **Collections** efficiently manage groups of objects
7. **Multithreading** improves performance
8. **File I/O** enables persistence

---

**üí° Pro Tip**: Understanding these concepts is crucial for building maintainable, scalable, and robust applications!
